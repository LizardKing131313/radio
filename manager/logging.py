"""
Structured logging setup based on structlog.

Features:
- JSON logs to stderr
- Log level from env var LOG_LEVEL (DEBUG|INFO|WARNING|ERROR|CRITICAL)
- Correlation via run_id (env RUN_ID, param, or autogenerated)
- Unifies structlog and stdlib logging
- Context propagation with contextvars (bind_context/run_id helpers)

export LOG_LEVEL=INFO
export RUN_ID=localdev-123
"""

from __future__ import annotations

import logging
import os
import sys
import uuid
from typing import Any

import structlog
from structlog.contextvars import (
    bind_contextvars,
    clear_contextvars,
    get_contextvars,
    merge_contextvars,
)
from structlog.processors import JSONRenderer
from structlog.stdlib import LoggerFactory, ProcessorFormatter
from structlog.typing import FilteringBoundLogger


# ---- Public API -----------------------------------------------------------------


def configure_logging(run_id: str | None = None) -> str:
    """
    Configure structlog + stdlib logging for JSON output and bind run_id.

    Returns the effective run_id.
    """
    level: int = _parse_log_level(os.getenv("LOG_LEVEL"))
    ts = structlog.processors.TimeStamper(fmt="iso", utc=True)

    # Route stdlib logs -> structlog ProcessorFormatter -> JSON
    formatter = ProcessorFormatter(
        processor=JSONRenderer(),
        foreign_pre_chain=[
            merge_contextvars,  # include contextvars (e.g., run_id) in stdlib logs
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            ts,
        ],
    )

    handler = logging.StreamHandler(stream=sys.stderr)
    handler.setFormatter(formatter)

    root = logging.getLogger()
    root.handlers.clear()
    root.addHandler(handler)
    root.setLevel(level)

    # Configure structlog to pass through the ProcessorFormatter
    structlog.configure(
        processors=[
            merge_contextvars,
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            ts,
            structlog.processors.format_exc_info,
            ProcessorFormatter.wrap_for_formatter,  # hand off to stdlib formatter
        ],
        logger_factory=LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True,
    )

    effective_run_id: str = run_id or os.getenv("RUN_ID") or _generate_run_id()
    bind_contextvars(run_id=effective_run_id)
    return effective_run_id


def get_logger(name: str) -> FilteringBoundLogger:
    """Get a structlog logger bound to `name`."""
    return structlog.get_logger(name)


def set_run_id(new_run_id: str | None = None) -> str:
    """
    Set or overwrite the current run_id in contextvars.
    Returns the effective run_id.
    """
    rid: str = new_run_id or _generate_run_id()
    bind_contextvars(run_id=rid)
    return rid


def get_run_id() -> str | None:
    """Get current run_id from contextvars."""
    ctx: dict[str, Any] = dict(get_contextvars())
    rid = ctx.get("run_id")
    return str(rid) if rid is not None else None


def bind_context(**kwargs: str | int | float | bool) -> None:
    """
    Bind arbitrary key/value pairs into the logging context (contextvars).
    Example: bind_context(request_id="abc123", user="alice")
    """
    bind_contextvars(**kwargs)


def reset_log_context() -> None:
    """Clear all contextvars used by structlog."""
    clear_contextvars()


# ---- Internals -------------------------------------------------------------------


def _parse_log_level(value: str | None) -> int:
    if not value:
        return logging.INFO
    normalized = value.strip().upper()
    mapping: dict[str, int] = {
        "CRITICAL": logging.CRITICAL,
        "ERROR": logging.ERROR,
        "WARN": logging.WARNING,
        "WARNING": logging.WARNING,
        "INFO": logging.INFO,
        "DEBUG": logging.DEBUG,
        "NOTSET": logging.NOTSET,
    }
    return mapping.get(normalized, logging.INFO)


def _generate_run_id() -> str:
    # Short, k8s/log-friendly correlation id
    return uuid.uuid4().hex[:12]
